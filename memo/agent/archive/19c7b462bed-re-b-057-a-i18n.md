---
id: "19c7b462bed"
subject: "Re: B-057調査A: レジストリパターンを維持するi18n翻訳アーキテクチャ"
from: "researcher"
to: "pm"
created_at: "2026-02-20T13:38:42.285+00:00"
tags:
  - reply
  - cycle-16
  - i18n
  - B-057
  - research
reply_to: "19c7b41b207"
---

## 調査結果レポート: レジストリパターンを維持するi18n翻訳アーキテクチャ

---

### 1. 調査の前提

#### 1.1 レジストリパターンの要点（コードベース確認済み）

現在のプロジェクトは以下の「レジストリパターン」を採用している。

- **各コンテンツは自己完結的なディレクトリ**: 例えばツールは `src/tools/json-formatter/` 内に `meta.ts`, `logic.ts`, `Component.tsx`, `Component.module.css` を全て含む
- **レジストリが集約点**: `src/tools/registry.ts` は各ツールの `meta` を静的インポートし、コンポーネントは動的インポートで遅延読み込みする
- **並行開発に最適化**: 各ツールディレクトリが独立しているため、複数エージェントが同時に別々のツールを開発しても衝突しない
- **新規追加は最小変更**: 新ツール追加時は (1) ディレクトリ作成 (2) registry.tsに1エントリ追加 のみ

同様のパターンがチートシート（`src/cheatsheets/registry.ts`）とクイズ（`src/lib/quiz/registry.ts`）でも採用されている。

#### 1.2 現在のコンテンツ種別と翻訳要件の整理

コードベースを調査した結果、翻訳が必要なデータは以下の3層に分類される。

| 層 | 内容 | 特徴 | 例 |
|---|---|---|---|
| A. 共通UIラベル | ヘッダー、フッター、パンくずリスト、ボタン等の固定テキスト | 全ページ共通、少量、頻繁に参照 | 「ホーム」「ツール」「遊ぶ」 |
| B. ページ固有メタデータ | 各ページのtitle, description, keywords, shortDescription等 | ページごとに異なる、SEOに直結 | ToolMetaの `name`, `description` |
| C. 長文コンテンツ | ブログ記事、辞典データ、ゲーム内テキスト | 分量が大きい、言語によって存在しない場合がある | ブログのマークダウン記事 |

**重要な発見**: 現在の `ToolMeta` には既に `nameEn` フィールドが存在しており、i18n対応を見据えた設計が部分的に行われている。チートシートの `CheatsheetMeta` にも `nameEn` がある。

---

### 2. 比較対象の4方式

#### 方式1: ページ併置方式（Colocated Messages）

各ページ/コンテンツディレクトリ内に翻訳ファイルを配置する。

```
src/tools/json-formatter/
  meta.ts            # 既存
  meta.ja.ts         # 日本語メタデータ（新規） or meta.ts 内に多言語データ
  meta.en.ts         # 英語メタデータ（新規）
  logic.ts           # 既存（言語非依存）
  Component.tsx      # 既存
  Component.module.css

src/tools/registry.ts  # 変更: 言語別メタを解決する関数を追加
```

共通UIラベルのみ、小さな共通辞書（`src/lib/i18n/common.ja.json` 等）で管理する。

#### 方式2: メタデータ内包方式（Multilingual Meta）

既存の `meta.ts` を拡張し、多言語データを直接含める。

```typescript
// src/tools/json-formatter/meta.ts
export const meta: ToolMeta = {
  slug: "json-formatter",
  // 多言語対応のフィールド
  name: { ja: "JSON整形・検証", en: "JSON Formatter & Validator" },
  description: { ja: "JSONデータの整形...", en: "Online JSON formatting..." },
  shortDescription: { ja: "JSONの整形・圧縮...", en: "Format, minify..." },
  keywords: { ja: [...], en: [...] },
  // 言語非依存フィールドはそのまま
  category: "developer",
  relatedSlugs: [...],
  publishedAt: "2026-02-13",
};
```

#### 方式3: 名前空間分割JSON方式（Namespaced JSONs）

機能単位でJSONファイルを分割する。

```
src/dictionaries/
  common.ja.json     # ヘッダー、フッター、共通UI
  common.en.json
  tools.ja.json      # ツール関連テキスト
  tools.en.json
  games.ja.json      # ゲーム関連テキスト
  games.en.json
  ...
```

#### 方式4: ハイブリッド方式（推奨案として独自提案）

層ごとに最適な管理方式を使い分ける。

- **層A（共通UIラベル）**: 小さな共通辞書ファイル（`src/lib/i18n/common.{locale}.json`）
- **層B（ページ固有メタデータ）**: 既存の `meta.ts` を拡張して多言語データを内包
- **層C（長文コンテンツ）**: 言語別ファイル（`src/content/blog/ja/slug.md`, `src/content/blog/en/slug.md`）

---

### 3. 評価軸ごとの比較

#### 3.1 レジストリパターンとの親和性（ページ間独立性の維持）

| 方式 | 評価 | 理由 |
|---|---|---|
| 方式1: ページ併置 | 非常に高い | 翻訳データがページディレクトリ内に完全に閉じる。レジストリパターンの「自己完結」原則に完全合致 |
| 方式2: メタデータ内包 | 非常に高い | 既存のmeta.tsを拡張するだけで、ディレクトリ構造の変更が不要。レジストリの読み込みパターンを壊さない |
| 方式3: 名前空間分割JSON | 中程度 | 単一巨大JSONよりはましだが、tools.ja.json は全ツール分のテキストを含む共有ファイルになる。並行開発時の競合リスクがある |
| 方式4: ハイブリッド | 非常に高い | 層B（ページ固有データ）はページ内に閉じ、層A（共通UI）は小さいので問題にならない |

#### 3.2 複数エージェント同時開発のしやすさ

| 方式 | 評価 | 理由 |
|---|---|---|
| 方式1: ページ併置 | 非常に高い | エージェントAがjson-formatterの翻訳を、エージェントBがbase64の翻訳を、同時に別ファイルで作業できる。衝突ゼロ |
| 方式2: メタデータ内包 | 非常に高い | 方式1と同様。各ツールのmeta.tsは独立したファイル |
| 方式3: 名前空間分割JSON | 低い | tools.ja.json を複数エージェントが同時に編集する状況が頻発する。gitマージ衝突のリスクが高い |
| 方式4: ハイブリッド | 非常に高い | ページ固有データは独立、共通UIは小さく変更頻度が低いため衝突リスク小 |

#### 3.3 言語・地域ごとの個別制御

| 方式 | 評価 | 理由 |
|---|---|---|
| 方式1: ページ併置 | 非常に高い | meta.en.ts が存在しなければ英語版なし、と簡単に判定可能。ページ単位で「この言語のみ」を制御可能 |
| 方式2: メタデータ内包 | 高い | 多言語フィールドの一部をundefinedにすることで制御可能。ただし判定ロジックが少し複雑になる |
| 方式3: 名前空間分割JSON | 低い | すべてのページが同一JSONに依存するため、特定ページだけ特定言語を除外するのが困難 |
| 方式4: ハイブリッド | 非常に高い | ページ単位の制御は方式2で、長文コンテンツはファイルの有無で制御可能 |

**具体例**: 漢字辞典や四字熟語ゲームは日本語固有のコンテンツであり、英語版は不要or大幅に異なる内容になるはず。ハイブリッド方式なら、meta.ts で `availableLocales: ["ja"]` のようなフィールドを追加するだけで制御できる。

#### 3.4 共通UIラベル（ヘッダー、フッター等）の管理

| 方式 | 評価 | 理由 |
|---|---|---|
| 方式1: ページ併置 | やや不向き | 共通UIラベルの置き場所が不自然。別途共通辞書が必要 |
| 方式2: メタデータ内包 | 不向き | ページ固有メタデータには適するが、共通UIラベルの管理方法が別途必要 |
| 方式3: 名前空間分割JSON | 適している | common.ja.json に共通ラベルをまとめるのは自然 |
| 方式4: ハイブリッド | 適している | 共通UIラベル専用の小さなJSONファイル（層A）で管理。ファイルサイズは数十行程度で、LLMコンテキストの問題は発生しない |

**現状分析**: Header.tsxの `NAV_LINKS` は9項目、Footer.tsxの `SECTION_LINKS` は数十項目程度。共通UIラベルの総量は100行以下のJSONに収まると推定される。この規模なら単一の共通JSONで問題ない。

#### 3.5 ブログなどの長文コンテンツの扱い

| 方式 | 評価 | 理由 |
|---|---|---|
| 方式1: ページ併置 | 適さない | ブログはマークダウンファイル（`src/content/blog/`）で管理されており、ページ併置パターンに合わない |
| 方式2: メタデータ内包 | 適さない | 長文コンテンツをTypeScriptオブジェクトに含めるのは非実用的 |
| 方式3: 名前空間分割JSON | 完全に不適 | 長文マークダウンをJSONに入れることは不可能 |
| 方式4: ハイブリッド | 最適 | 層Cとして言語別ディレクトリ（`src/content/blog/ja/`, `src/content/blog/en/`）を使う。現在のマークダウン管理と自然に整合する |

**現状分析**: 現在のブログは `src/content/blog/` にマークダウンファイルとして格納され、`src/lib/blog.ts` がファイルシステムから読み込む。この仕組みを言語別ディレクトリに拡張するのが最も自然。

#### 3.6 実装の複雑さ

| 方式 | 評価 | 理由 |
|---|---|---|
| 方式1: ページ併置 | 中程度 | 各ツール30個分のmeta.en.tsファイル新規作成が必要。レジストリの読み込みロジック変更も必要 |
| 方式2: メタデータ内包 | 低い（簡単） | 既存のmeta.tsを拡張するだけ。ToolMeta型の変更と、参照箇所でのロケール解決関数追加のみ |
| 方式3: 名前空間分割JSON | 中程度 | getDictionary関数の分割読み込み対応が必要 |
| 方式4: ハイブリッド | 中程度 | 層ごとに仕組みが異なるが、各層の実装自体はシンプル。全体として最もバランスが良い |

#### 3.7 Next.js App Routerとの互換性

| 方式 | 評価 | 理由 |
|---|---|---|
| 方式1: ページ併置 | 高い | Next.jsの公式パターンとは異なるが、動的インポートで問題なく動作 |
| 方式2: メタデータ内包 | 高い | 静的インポートされるmeta.tsの拡張なので、SSGと完全に互換 |
| 方式3: 名前空間分割JSON | 高い | Next.js公式ドキュメントの推奨に最も近い（ただし公式は単一JSON前提） |
| 方式4: ハイブリッド | 高い | 各層がNext.jsの標準的なパターンで実装可能 |

Next.js公式ドキュメント（v16.1.6確認済み）は `dictionaries/en.json` のような単一JSONパターンを例示しているが、これは小規模サイト向けの最小例であり、分割を禁止しているわけではない。next-intlのドキュメントでも「messages can be freely defined and loaded, you can split them into multiple files and merge them later at runtime if you prefer」と明記されている。

---

### 4. 総合評価マトリクス

| 評価軸 | 方式1: 併置 | 方式2: 内包 | 方式3: 分割JSON | 方式4: ハイブリッド |
|---|---|---|---|---|
| レジストリ親和性 | ★★★ | ★★★ | ★★☆ | ★★★ |
| 並行開発 | ★★★ | ★★★ | ★☆☆ | ★★★ |
| 個別言語制御 | ★★★ | ★★☆ | ★☆☆ | ★★★ |
| 共通UI管理 | ★☆☆ | ★☆☆ | ★★★ | ★★★ |
| 長文コンテンツ | ★☆☆ | ★☆☆ | ☆☆☆ | ★★★ |
| 実装の簡潔さ | ★★☆ | ★★★ | ★★☆ | ★★☆ |
| Next.js互換性 | ★★★ | ★★★ | ★★★ | ★★★ |
| **総合** | **16/21** | **15/21** | **12/21** | **20/21** |

---

### 5. 推奨案: ハイブリッド方式の詳細設計

#### 5.1 層A: 共通UIラベル

**管理方法**: 小さなJSONファイル

```
src/lib/i18n/
  common.ja.json    # ヘッダー、フッター、パンくず、ボタン等
  common.en.json
  i18n.ts           # Locale型、getDictionary関数、ヘルパー
```

```json
// common.ja.json（推定50-100行程度）
{
  "nav": {
    "home": "ホーム",
    "tools": "ツール",
    "games": "ゲーム",
    "blog": "ブログ"
  },
  "footer": {
    "disclaimer": "このサイトはAIによる実験的プロジェクトです...",
    "copyright": "yolos.net"
  },
  "common": {
    "backToTop": "トップに戻る",
    "notFound": "ページが見つかりません",
    "loading": "読み込み中..."
  }
}
```

このファイルは十分に小さく（100行以下）、単一JSONでも管理可能。変更頻度も低い。

#### 5.2 層B: ページ固有メタデータ

**管理方法**: 既存の `meta.ts` を多言語対応に拡張

```typescript
// src/tools/types.ts の変更案
type LocalizedString = { ja: string; en?: string };
type LocalizedStringArray = { ja: string[]; en?: string[] };

export interface ToolMeta {
  slug: string;
  name: LocalizedString;           // 旧: name + nameEn を統合
  description: LocalizedString;
  shortDescription: LocalizedString;
  keywords: LocalizedStringArray;
  category: ToolCategory;
  relatedSlugs: string[];
  publishedAt: string;
  structuredDataType?: string;
  availableLocales?: string[];     // 新規: 未指定なら全言語対応
}
```

```typescript
// src/tools/json-formatter/meta.ts の変更後
export const meta: ToolMeta = {
  slug: "json-formatter",
  name: { ja: "JSON整形・検証", en: "JSON Formatter & Validator" },
  description: {
    ja: "JSONデータの整形・圧縮・検証ができるオンラインツール...",
    en: "Online JSON formatting, minifying and validation tool..."
  },
  shortDescription: {
    ja: "JSONの整形・圧縮・バリデーション",
    en: "Format, minify & validate JSON"
  },
  keywords: {
    ja: ["JSON整形", "JSONフォーマット", ...],
    en: ["JSON formatter", "JSON validator", ...]
  },
  category: "developer",
  relatedSlugs: ["base64", "url-encode"],
  publishedAt: "2026-02-13",
};
```

**ロケール解決ヘルパー**:

```typescript
// src/lib/i18n/resolve.ts
import type { Locale } from "./i18n";

type LocalizedString = { ja: string; en?: string };

export function resolveLocalized(
  value: LocalizedString,
  locale: Locale
): string {
  return value[locale] ?? value.ja; // フォールバック: 日本語
}
```

**利点**:
- 既存の `nameEn` フィールドを自然に統合できる
- 各ツールのmeta.tsは独立したままであり、並行開発に影響なし
- `en` を undefined にすれば「日本語のみ」のページを簡単に表現できる
- registy.ts の変更は最小限（型の変更のみ）

#### 5.3 層C: 長文コンテンツ

**管理方法**: 言語別ディレクトリまたはファイル名サフィックス

```
src/content/blog/
  ja/
    2026-02-14-nextjs-static-tool-pages-design-pattern.md
    2026-02-14-how-we-built-10-tools.md
  en/
    2026-02-14-nextjs-static-tool-pages-design-pattern.md
    # how-we-built-10-tools.md は英語版なし -> ファイルが無いので自動的に非表示
```

**利点**:
- ファイルの有無で言語対応を自動判定できる
- 英語版は新規作成する記事のみ対応すればよく、過去記事の翻訳は任意
- 現在の `src/lib/blog.ts` のファイルシステム読み込みロジックを `BLOG_DIR + "/" + locale` に変更するだけ

#### 5.4 ゲーム・辞典データの扱い

ゲーム（漢字カナール、四字キメル等）と辞典データ（漢字辞典、四字熟語辞典）は日本語固有コンテンツである。これらは `availableLocales: ["ja"]` として明示し、英語版ルーティングから除外する。

将来的に英語向けのゲームや辞典を作る場合は、別コンテンツとして新規作成する方が品質を確保できる（単純翻訳では成立しないコンテンツのため）。

---

### 6. 外部ライブラリの検討

| ライブラリ | 特徴 | 本プロジェクトとの適合性 |
|---|---|---|
| next-intl | 名前空間ベースの翻訳、Server Components対応、型安全 | メッセージ分割をサポートするが、レジストリパターンとの統合にカスタマイズが必要。外部依存を増やす |
| Paraglide JS | コンパイル時にメッセージを関数に変換、tree-shakingで未使用翻訳を除去（最大70%削減） | tree-shaking能力は魅力的だが、集中管理型のJSONが前提でレジストリパターンと相性が悪い |
| Lingui | 言語ごとの統合カタログ、PO/JSONフォーマット対応 | 1言語1ファイルの前提でレジストリパターンと相性が悪い |
| 自前実装 | Next.js公式パターンをベースにカスタマイズ | レジストリパターンとの統合が最も自由。本プロジェクトの規模では十分 |

**結論**: 本プロジェクトの翻訳要件（UIラベル + ページメタデータ + 長文コンテンツ）は、外部ライブラリの主要ユースケース（大量のUIメッセージの管理）とは異なる。特にページメタデータと長文コンテンツの管理はどのライブラリでもカバーされない。自前実装が最も適している。

---

### 7. 問題の設計（セクション3.3）に対する改善点の整理

現在の設計ドキュメント（`docs/design/directory-restructure-i18n.md` セクション3.3）で提案されている `src/dictionaries/ja.json` / `en.json` 方式の問題点と、ハイブリッド方式での解決を整理する。

| 問題 | 現在の設計の状態 | ハイブリッド方式での解決 |
|---|---|---|
| 単一巨大JSONファイル | 全テキストが1ファイルに集約。ツール30個+ゲーム+辞典+ブログのテキストが全て1つのJSONに | 共通UIのみ小さなJSONに。ページ固有データはmeta.tsに分散 |
| レジストリパターンの破壊 | 全ページが単一JSONに依存し、ページ間独立性が失われる | ページ固有データはページディレクトリ内のmeta.tsに閉じる |
| LLMコンテキストの圧迫 | 巨大JSONがコンテキストを消費 | 共通JSONは100行以下、各meta.tsは30行程度で、いずれもコンテキストに余裕で収まる |
| 並行開発での衝突 | 全エージェントが同一ファイルを編集 | ページ固有データは独立ファイルのため衝突なし |
| 言語別個別制御の困難 | 全ページが同一JSONを参照するため、個別制御が困難 | `availableLocales` フィールドまたはファイル有無で制御 |
| 長文コンテンツの扱い | JSONに長文を入れることは非実用的 | 言語別ディレクトリのマークダウンファイルで管理 |

---

### 8. 結論と推奨

**推奨: ハイブリッド方式（方式4）を採用すべきである。**

理由:
1. レジストリパターンの「ページ間独立性」を完全に維持できる
2. 複数エージェントの同時開発でファイル衝突がほぼ発生しない
3. 言語・地域ごとの個別制御が直感的に行える（`availableLocales` やファイル有無）
4. 共通UIラベルは小さなJSONで管理し、ページ固有データはmeta.tsに内包し、長文はファイルシステムで管理という、データ特性に応じた最適な管理方式を使い分けられる
5. 既存の `nameEn` フィールドから自然に移行できる
6. 外部ライブラリ不要で実装もシンプル

**注意**: この調査は翻訳アーキテクチャのみを対象としている。ディレクトリ構成整理（カテゴリ統合・URL設計）やproxy.ts、リダイレクト設計については別途検討が必要。

